# How to Use the WRF Application Software 

**Documentation:** [Weather Research Framework (WRF) Model](https://www.mmm.ucar.edu/models/wrf)

*The [WRF](https://www.mmm.ucar.edu/models/wrf) model is a state of the art mesoscale numerical weather prediction system designed for both atmospheric research and operational forecasting applications.*

## Getting Started

This section provides the minimum amount of information necessary to successfully run a WRF job on an NREL Cluster. First, we show how to use WRF given that we have different versions of WRF already built and available as modules.


```
% module avail wrf
     wrf/4.1.3/intel-20.1.217-mpi (D)    wrf/4.2.1/intel-20.1.217-mpi
     
```

The `module avail wrf` command shows that two WRF modules are
available for two different versions of WRF and built with the intel
compiler v20.1 toolchain. This command also shows that the version
4.1.3 is the default build which is automatically loaded with `module
load wrf`. Users are free to choose any of the module versions
available for use. Currently there are no modules to run WRF on GPUs, but
there is current effort underway to make that available on future systems.

Next, we look at how to use the WRF module. Below is an example job script:

### Example Job Script

??? example "Kestrel CPU"

	```slurm
	#!/bin/bash

	# In a comment summarize the hardware requested, e.g. number of nodes, 
        # number of tasks per node

	#SBATCH --time=
	#SBATCH --nodes=
	#SBATCH --ntasks-per-node=
	#SBATCH --partition=
	#SBATCH --exclusive=user
	#SBATCH --account=
	#SBATCH --export=ALL
	#SBATCH --job-name
	#SBATCH --output=out_%j

	# include a section of relevant export environment and module load commands, e.g.:

	  module load cray-hdf5
	  module load cray-netcdf


	  export LD_LIBRARY_PATH=/opt/cray/pe/netcdf/default/CRAYCLANG/14.0/lib:/opt/cray/pe/hdf5/1.12.2.1/CRAYCLANG/14.0/lib:/sfs/nopt/nrel/apps/testing/apurkaya/wrf/cray/installs/pnetcdf/lib:$LD_LIBRARY_PATH
	  export HDF5=/opt/cray/pe/hdf5/1.12.2.1/CRAYCLANG/14.0
	  export NETCDF=/opt/cray/pe/netcdf/default/CRAYCLANG/14.0
	  export PNETCDF=/sfs/nopt/nrel/apps/testing/apurkaya/wrf/cray/installs/pnetcdf

	  # Note that builds with different toolchains may require different modules and environments to be loaded

 	  export OMP_NUM_THREADS=1

	# include a sample srun command or similar
	srun wrf.exe

	```



To submit the above wrf jobscript named `submit_wrf.sh`, do ``` sbatch submit_wrf.sh ```

## Supported Versions

| Kestrel |
|:-------:
| 4.2.2   | 

## Advanced

Include advanced user information about how to build the application software from source.

One common "advanced case" might be that users want to build their own version of the code.

### Building Instructions From Source

Any WRF version can be downloaded [here](https://github.com/wrf-model/WRF/releases). Pursuant to building WRF, appropriate versions of `netcdf`, `hdf5` and `pnetcdf` (if parallel netcdf is required) must also be built since they are dependent for building WRF. These dependent supporting softwares may already be offered as modules. If not, then users need to build them first, instructions for which are not provided here. 

??? example "Building on Kestrel"

    The following `configure.wrf` file was used to build WRF v4.2.2 on Kestral (to date). Copy this configure.wrf into your WRF build dir WRF-4.x.y, and do `% cd WRF-4.x.y`.
    ```
    # configure.wrf
    #
    # Original configure options used:
    # ./configure 
    # Compiler choice: 47
    # Nesting option: 1
    #
    # This file was automatically generated by the configure script in the
    # top level directory. You may make changes to the settings in this
    # file but be aware they will be overwritten each time you run configure.
    # Ordinarily, it is necessary to run configure once, when the code is
    # first installed.
    #
    # To permanently change options, change the settings for your platform
    # in the file arch/configure.defaults then rerun configure.
    #
    SHELL           =       /bin/sh
    DEVTOP          =       `pwd`
    LIBINCLUDE      =       .
    .SUFFIXES: .F .i .o .f90 .c


    #### Get core settings from environment (set in compile script)
    #### Note to add a core, this has to be added to.

    COREDEFS = -DEM_CORE=$(WRF_EM_CORE) \
    -DNMM_CORE=$(WRF_NMM_CORE) -DNMM_MAX_DIM=2600 \
    -DDA_CORE=$(WRF_DA_CORE) \
    -DWRFPLUS=$(WRF_PLUS_CORE)

    #### Single location for defining total number of domains.  You need
    #### at least 1 + 2*(number of total nests).  For example, 1 coarse
    #### grid + three fine grids = 1 + 2(3) = 7, so MAX_DOMAINS=7.

    MAX_DOMAINS	=	21

    #### DM buffer length for the configuration flags.

    CONFIG_BUF_LEN	=	65536

    #### Size of bitmasks (in 4byte integers) of stream masks for WRF I/O

    MAX_HISTORY = 25

    IWORDSIZE = 4
    DWORDSIZE = 8
    LWORDSIZE = 4

    ##############################################################################
    #### The settings in this section are defaults that may be overridden by the
    #### architecture-specific settings in the next section.  
    ##############################################################################

    ##############################################################################
	#### NOTE:  Do not modify these default values here.  To override these 
	####        values, make changes after "Architecture specific settings".  
	##############################################################################

	#### Native size (in bytes) of Fortran REAL data type on this architecture ####
	#### Note:  to change real wordsize (for example, to promote REALs from 
	####        4-byte to 8-byte), modify the definition of RWORDSIZE in the 
	####        section following "Architecture specific settings".  Do not 
	####        change NATIVE_RWORDSIZE as is it architecture-specific.  
	NATIVE_RWORDSIZE = 4

	#### Default sed command and script for Fortran source files ####
	#SED_FTN = sed -f $(WRF_SRC_ROOT_DIR)/arch/standard.sed
	SED_FTN = $(WRF_SRC_ROOT_DIR)/tools/standard.exe

	# Hack to work around $(PWD) not changing during OSF1 build.  
	# $(IO_GRIB_SHARE_DIR) is reset during the OSF1 build only.  
	IO_GRIB_SHARE_DIR = 

	#### ESMF switches                 ####
	#### These are set up by Config.pl ####
	# switch to use separately installed ESMF library for coupling:  1==true
	ESMF_COUPLING       = 0
	# select dependences on module_utility.o
	ESMF_MOD_DEPENDENCE = $(WRF_SRC_ROOT_DIR)/external/esmf_time_f90/module_utility.o
	# select -I options for external/io_esmf vs. external/esmf_time_f90
	ESMF_IO_INC         = -I$(WRF_SRC_ROOT_DIR)/external/esmf_time_f90
	# select -I options for separately installed ESMF library, if present
	ESMF_MOD_INC        =  $(ESMF_IO_INC)
	# select cpp token for external/io_esmf vs. external/esmf_time_f90
	ESMF_IO_DEFS        = 
	# select build target for external/io_esmf vs. external/esmf_time_f90
	ESMF_TARGET         = esmf_time

	# ESMFINCLUDEGOESHERE


	#### NETCDF4 pieces

	NETCDF4_IO_OPTS = -DUSE_NETCDF4_FEATURES -DWRFIO_NCD_LARGE_FILE_SUPPORT
	GPFS            =
	CURL            =
	HDF5            =
	ZLIB            =
	DEP_LIB_PATH    = 
	NETCDF4_DEP_LIB = $(DEP_LIB_PATH) $(HDF5) $(ZLIB) $(GPFS) $(CURL)

	# NETCDF4INCLUDEGOESHERE


	##############################################################################

	LIBWRFLIB = libwrflib.a

	 LIB_BUNDLED     = \
			      $(WRF_SRC_ROOT_DIR)/external/fftpack/fftpack5/libfftpack.a \
			      $(WRF_SRC_ROOT_DIR)/external/io_grib1/libio_grib1.a \
			      $(WRF_SRC_ROOT_DIR)/external/io_grib_share/libio_grib_share.a \
			      $(WRF_SRC_ROOT_DIR)/external/io_int/libwrfio_int.a \
			      $(ESMF_IO_LIB) \
			      $(WRF_SRC_ROOT_DIR)/external/RSL_LITE/librsl_lite.a \
			      $(WRF_SRC_ROOT_DIR)/frame/module_internal_header_util.o \
			      $(WRF_SRC_ROOT_DIR)/frame/pack_utils.o

	 LIB_EXTERNAL    = \
			      -L$(WRF_SRC_ROOT_DIR)/external/io_netcdf -lwrfio_nf -L/opt/cray/pe/netcdf/default/CRAYCLANG/14.0/lib -lnet
	cdff -lnetcdf  -L$(WRF_SRC_ROOT_DIR)/external/io_pnetcdf -lwrfio_pnf -L/sfs/nopt/nrel/apps/testing/$USER/wrf/cray/installs/pn
	etcdf/lib -lpnetcdf   -L/opt/cray/pe/hdf5/1.12.2.1/CRAYCLANG/14.0/lib -lhdf5hl_fortran -lhdf5_hl -lhdf5_fortran -lhdf5 -lm -lz


	#### Architecture specific settings ####

	# Settings for    Cray XE and XC CLE/Linux x86_64, Cray CCE compiler  (dm+sm)
	# Use this for both XE6 systems with AMD Opteron and XC with Intel x86_64

	DESCRIPTION     =       CRAY CCE ($SFC/$SCC): Cray XE and XC
	# OpenMP is enabled by default for Cray CCE compiler
	# This turns it off
	NOOMP           =       -hnoomp
	DMPARALLEL      =        1
	OMPCPP          =        -D_OPENMP
	OMP             =        -homp
	OMPCC           =        -homp
	SFC             =       ftn $(NOOMP)
	SCC             =       cc 
	CCOMP           =       cc 
	DM_FC           =       ftn $(NOOMP)
	DM_CC           =       cc
	FC              =       $(DM_FC)
	CC              =       $(DM_CC) -DFSEEKO64_OK 
	LD              =       $(FC)
	RWORDSIZE       =       $(NATIVE_RWORDSIZE)
	PROMOTION       =       -s integer32 -s real`expr 8 \* $(RWORDSIZE)`
	ARCH_LOCAL      =       -DNONSTANDARD_SYSTEM_SUBR  -DWRF_USE_CLM $(NETCDF4_IO_OPTS)
	CFLAGS_LOCAL    =       -O3  # -DRSL0_ONLY
	LDFLAGS_LOCAL   =       
	# uncomment this for wrfda build
	#LIB_LOCAL       =       -L$(WRF_SRC_ROOT_DIR)/external/fftpack/fftpack5 -lfftpack \
	#                        -L$(WRF_SRC_ROOT_DIR)/external/RSL_LITE -lrsl_lite
	CPLUSPLUSLIB    =       
	ESMF_LDFLAG     =       $(CPLUSPLUSLIB)
	FCOPTIM         =       # -Ofp3 
	FCREDUCEDOPT	=       $(FCOPTIM)
	FCNOOPT		=       -O1 -Ofp1 -Oipa0 -Onomodinline
	FCDEBUG         =       # -g -O0 # -K trap=fp -R bc
	FORMAT_FIXED    =       -f fixed
	FORMAT_FREE     =       -f free
	FCSUFFIX        =
	BYTESWAPIO      =       -h byteswapio
	FCBASEOPTS_NO_G =       -N1023 $(FORMAT_FREE) $(BYTESWAPIO) #-ra
	FCBASEOPTS      =       $(FCBASEOPTS_NO_G) $(FCDEBUG)
	MODULE_SRCH_FLAG =     
	TRADFLAG        =      -traditional-cpp $(NETCDF4_IO_OPTS)
	CPP             =      /lib/cpp -P -nostdinc
	AR              =      ar
	ARFLAGS         =      ru
	M4              =      m4
	RANLIB          =      ranlib
	RLFLAGS		=	
	CC_TOOLS        =      gcc

	###########################################################
	######################
	# POSTAMBLE

	FGREP = fgrep -iq

	ARCHFLAGS       =    $(COREDEFS) -DIWORDSIZE=$(IWORDSIZE) -DDWORDSIZE=$(DWORDSIZE) -DRWORDSIZE=$(RWORDSIZE) -DLWORDSIZE=$(LWORDS
	IZE) \
			     $(ARCH_LOCAL) \
			     $(DA_ARCHFLAGS) \
			      -DDM_PARALLEL \
			       \
			      -DNETCDF \
			      -DPNETCDF \
			      -DPNETCDF_QUILT \
			       \
			       \
			       \
			       \
			      -DHDF5 \
			       -DLANDREAD_STUB=1 \
			       \
			       \
			      -DUSE_ALLOCATABLES \
			      -Dwrfmodel \
			      -DGRIB1 \
			      -DINTIO \
			      -DKEEP_INT_AROUND \
			      -DLIMIT_ARGS \
			      -DBUILD_RRTMG_FAST=0 \
			      -DBUILD_RRTMK=0 \
			      -DBUILD_SBM_FAST=1 \
			      -DSHOW_ALL_VARS_USED=0 \
			      -DCONFIG_BUF_LEN=$(CONFIG_BUF_LEN) \
			      -DMAX_DOMAINS_F=$(MAX_DOMAINS) \
			      -DMAX_HISTORY=$(MAX_HISTORY) \
			      -DNMM_NEST=$(WRF_NMM_NEST)
	CFLAGS          =    $(CFLAGS_LOCAL) -DDM_PARALLEL  \
			      -DLANDREAD_STUB=1 \
			      -DMAX_HISTORY=$(MAX_HISTORY) -DNMM_CORE=$(WRF_NMM_CORE)
	FCFLAGS         =    $(FCOPTIM) $(FCBASEOPTS)
	ESMF_LIB_FLAGS  =    
	# ESMF 5 -- these are defined in esmf.mk, included above
	 ESMF_IO_LIB     =    -L$(WRF_SRC_ROOT_DIR)/external/esmf_time_f90 -lesmf_time
	ESMF_IO_LIB_EXT =    -L$(WRF_SRC_ROOT_DIR)/external/esmf_time_f90 -lesmf_time
	INCLUDE_MODULES =    $(MODULE_SRCH_FLAG) \
			     $(ESMF_MOD_INC) $(ESMF_LIB_FLAGS) \
			      -I$(WRF_SRC_ROOT_DIR)/main \
			      -I$(WRF_SRC_ROOT_DIR)/external/io_netcdf \
			      -I$(WRF_SRC_ROOT_DIR)/external/io_int \
			      -I$(WRF_SRC_ROOT_DIR)/frame \
			      -I$(WRF_SRC_ROOT_DIR)/share \
			      -I$(WRF_SRC_ROOT_DIR)/phys \
			      -I$(WRF_SRC_ROOT_DIR)/wrftladj \
			      -I$(WRF_SRC_ROOT_DIR)/chem -I$(WRF_SRC_ROOT_DIR)/inc \
			      -I$(NETCDFPATH)/include \
			      
	REGISTRY        =    Registry
	CC_TOOLS_CFLAGS = -DNMM_CORE=$(WRF_NMM_CORE)

	LIB             =    $(LIB_BUNDLED) $(LIB_EXTERNAL) $(LIB_LOCAL) $(LIB_WRF_HYDRO) $(NETCDF4_DEP_LIB)
	LDFLAGS         =    $(OMP) $(FCFLAGS) $(LDFLAGS_LOCAL) 
	ENVCOMPDEFS     =    
	WRF_CHEM	=	0 
	CPPFLAGS        =    $(ARCHFLAGS) $(ENVCOMPDEFS) -I$(LIBINCLUDE) $(TRADFLAG) 
	NETCDFPATH      =    /opt/cray/pe/netcdf/default/CRAYCLANG/14.0
	HDF5PATH        =    /opt/cray/pe/hdf5/1.12.2.1/CRAYCLANG/14.0
	WRFPLUSPATH     =    
	RTTOVPATH       =    
	PNETCDFPATH     =    /sfs/nopt/nrel/apps/testing/$USER/wrf/cray/installs/pnetcdf

	bundled:  io_only 
	external: io_only $(WRF_SRC_ROOT_DIR)/external/RSL_LITE/librsl_lite.a gen_comms_rsllite module_dm_rsllite $(ESMF_TARGET)
	io_only:  esmf_time wrfio_nf wrfio_pnf  \
		  wrf_ioapi_includes wrfio_grib_share wrfio_grib1 wrfio_int fftpack


	######################
	externals: io_only bundled external

	gen_comms_serial :
		( /bin/rm -f $(WRF_SRC_ROOT_DIR)/tools/gen_comms.c )

	module_dm_serial :
		( if [ ! -e module_dm.F ] ; then /bin/cp module_dm_warning module_dm.F ; cat module_dm_stubs.F >> module_dm.F ; fi )

	gen_comms_rsllite :
		( if [ ! -e $(WRF_SRC_ROOT_DIR)/tools/gen_comms.c ] ; then \
		  /bin/cp $(WRF_SRC_ROOT_DIR)/tools/gen_comms_warning $(WRF_SRC_ROOT_DIR)/tools/gen_comms.c ; \
		  cat $(WRF_SRC_ROOT_DIR)/external/RSL_LITE/gen_comms.c >> $(WRF_SRC_ROOT_DIR)/tools/gen_comms.c ; fi )

	module_dm_rsllite :
		( if [ ! -e module_dm.F ] ; then /bin/cp module_dm_warning module_dm.F ; \
		  cat $(WRF_SRC_ROOT_DIR)/external/RSL_LITE/module_dm.F >> module_dm.F ; fi )

	wrfio_nf : 
		( cd $(WRF_SRC_ROOT_DIR)/external/io_netcdf ; \
		  make $(J) NETCDFPATH="$(NETCDFPATH)" RANLIB="$(RANLIB)" CPP="$(CPP)" \
		  CC="$(SCC)" CFLAGS="$(CFLAGS)" \
		  FC="$(SFC) $(PROMOTION) $(OMP) $(FCFLAGS)" TRADFLAG="$(TRADFLAG)" AR="$(AR)" ARFLAGS="$(ARFLAGS)" )

	wrfio_pnf : 
		( cd $(WRF_SRC_ROOT_DIR)/external/io_pnetcdf ; \
		  make $(J) NETCDFPATH="$(PNETCDFPATH)" RANLIB="$(RANLIB)" CPP="$(CPP) $(ARCHFLAGS)" \
		  FC="$(FC) $(PROMOTION) $(OMP) $(FCFLAGS)" TRADFLAG="$(TRADFLAG)" AR="$(AR)" ARFLAGS="$(ARFLAGS)" )

	wrfio_grib_share :
		( cd $(WRF_SRC_ROOT_DIR)/external/io_grib_share ; \
		  make $(J) CC="$(SCC)" CFLAGS="$(CFLAGS)" RM="$(RM)" RANLIB="$(RANLIB)" CPP="$(CPP)" \
		  FC="$(SFC) $(PROMOTION) -I. $(FCDEBUG) $(FCBASEOPTS) $(FCSUFFIX)" TRADFLAG="$(TRADFLAG)" AR="$(AR)" ARFLAGS="$(ARFLAGS
	)" archive) 

	wrfio_grib1 :
		( cd $(WRF_SRC_ROOT_DIR)/external/io_grib1 ; \
		  make $(J) CC="$(SCC)" CFLAGS="$(CFLAGS)" RM="$(RM)" RANLIB="$(RANLIB)" CPP="$(CPP)" \
		  FC="$(SFC) $(PROMOTION) -I. $(FCDEBUG) $(FCBASEOPTS) $(FCSUFFIX)" TRADFLAG="$(TRADFLAG)" AR="$(AR)" ARFLAGS="$(ARFLAGS
	)" archive)
	wrfio_grib2 :
		( cd $(WRF_SRC_ROOT_DIR)/external/io_grib2 ; \
		  make $(J) CC="$(SCC)" CFLAGS="$(CFLAGS) " RM="$(RM)" RANLIB="$(RANLIB)" \
		  CPP="$(CPP)" \
		  FC="$(SFC) $(PROMOTION) -I. $(FCDEBUG) $(FCBASEOPTS) $(FCSUFFIX)" TRADFLAG="-traditional" AR="$(AR)" ARFLAGS="$(ARFLAG
	S)" \
		  FIXED="$(FORMAT_FIXED)" archive)

	wrfio_int : 
		( cd $(WRF_SRC_ROOT_DIR)/external/io_int ; \
		  make $(J) CC="$(CC)" CFLAGS_LOCAL="$(CFLAGS_LOCAL)" RM="$(RM)" RANLIB="$(RANLIB)" CPP="$(CPP)" \
		  FC="$(FC) $(PROMOTION) $(FCDEBUG) $(FCBASEOPTS) $(OMP)" FGREP="$(FGREP)" \
		  TRADFLAG="$(TRADFLAG)" AR="$(AR)" ARFLAGS="$(ARFLAGS)" ARCHFLAGS="$(ARCHFLAGS)" all )

	esmf_time : 
		( cd $(WRF_SRC_ROOT_DIR)/external/esmf_time_f90 ; \
		  make $(J) FC="$(SFC) $(PROMOTION) $(FCDEBUG) $(FCBASEOPTS)" RANLIB="$(RANLIB)" \
		  CPP="$(CPP) -I$(WRF_SRC_ROOT_DIR)/inc -I. $(ARCHFLAGS) $(TRADFLAG)" AR="$(AR)" ARFLAGS="$(ARFLAGS)" )

	fftpack :
		( cd $(WRF_SRC_ROOT_DIR)/external/fftpack/fftpack5 ; \
		  make $(J) FC="$(SFC)" FFLAGS="$(PROMOTION) $(FCDEBUG) $(FCBASEOPTS)" RANLIB="$(RANLIB)" AR="$(AR)" \
		  ARFLAGS="$(ARFLAGS)" CPP="$(CPP)" CPPFLAGS="$(CPPFLAGS)" RM="$(RM)" )

	atm_ocn :
		( cd $(WRF_SRC_ROOT_DIR)/external/atm_ocn ; \
		  make $(J) CC="$(SCC)" CFLAGS="$(CFLAGS) " RM="$(RM)" RANLIB="$(RANLIB)" \
		  CPP="$(CPP)" CPPFLAGS="$(CPPFLAGS)" \
		  FC="$(DM_FC) $(PROMOTION) -I. $(FCDEBUG) $(FCBASEOPTS) $(FCSUFFIX)" TRADFLAG="-traditional" AR="$(AR)" ARFLAGS="$(ARFL
	AGS)" \
		  FIXED="$(FORMAT_FIXED)" )

	$(WRF_SRC_ROOT_DIR)/external/RSL_LITE/librsl_lite.a :
		( cd $(WRF_SRC_ROOT_DIR)/external/RSL_LITE ; make $(J) CC="$(CC) $(CFLAGS)" \
		  FC="$(FC) $(FCFLAGS) $(OMP) $(PROMOTION) $(BYTESWAPIO)" \
		  CPP="$(CPP) -I. $(ARCHFLAGS) $(OMPCPP) $(TRADFLAG)" AR="$(AR)" ARFLAGS="$(ARFLAGS)" ;\
		  $(RANLIB) $(WRF_SRC_ROOT_DIR)/external/RSL_LITE/librsl_lite.a )

	######################
	#	Macros, these should be generic for all machines

	LN	=	ln -sf
	MAKE	=	make -i -r
	RM	= 	rm -f


	# These sub-directory builds are identical across all architectures

	wrf_ioapi_includes :
		( cd $(WRF_SRC_ROOT_DIR)/external/ioapi_share ; \
		  $(MAKE) NATIVE_RWORDSIZE="$(NATIVE_RWORDSIZE)" RWORDSIZE="$(RWORDSIZE)" AR="$(AR)" ARFLAGS="$(ARFLAGS)" )

	wrfio_esmf :
		( cd $(WRF_SRC_ROOT_DIR)/external/io_esmf ; \
		  make FC="$(FC) $(PROMOTION) $(FCDEBUG) $(FCBASEOPTS) $(ESMF_MOD_INC)" \
		  RANLIB="$(RANLIB)" CPP="$(CPP) $(POUND_DEF) " AR="$(AR)" ARFLAGS="$(ARFLAGS)" )

	#	There is probably no reason to modify these rules

	.F.i:
		$(RM) $@
		sed -e "s/^\!.*'.*//" -e "s/^ *\!.*'.*//" $*.F > $*.G
		$(CPP) -I$(WRF_SRC_ROOT_DIR)/inc $(CPPFLAGS) $*.G > $*.i
		mv $*.i $(DEVTOP)/pick/$*.f90
		cp $*.F $(DEVTOP)/pick

	.F.o:
		$(RM) $@
		sed -e "s/^\!.*'.*//" -e "s/^ *\!.*'.*//" $*.F > $*.G
		$(CPP) -I$(WRF_SRC_ROOT_DIR)/inc $(CPPFLAGS) $(OMPCPP) $*.G  > $*.bb
		$(SED_FTN) $*.bb | $(CPP) $(TRADFLAG) > $*.f90
		$(RM) $*.G $*.bb
		@ if echo $(ARCHFLAGS) | $(FGREP) 'DVAR4D'; then \
		  echo COMPILING $*.F for 4DVAR ; \
		  $(WRF_SRC_ROOT_DIR)/var/build/da_name_space.pl $*.f90 > $*.f90.tmp ; \
		  mv $*.f90.tmp $*.f90 ; \
		fi
		$(FC) -o $@ -c $(FCFLAGS) $(OMP) $(MODULE_DIRS) $(PROMOTION) $(FCSUFFIX) $*.f90
		

	.F.f90:
		$(RM) $@
		sed -e "s/^\!.*'.*//" -e "s/^ *\!.*'.*//" $*.F > $*.G
		$(SED_FTN) $*.G > $*.H 
		$(CPP) -I$(WRF_SRC_ROOT_DIR)/inc $(CPPFLAGS) $*.H  > $@
		$(RM) $*.G $*.H

	.f90.o:
		$(RM) $@
		$(FC) -o $@ -c $(FCFLAGS) $(PROMOTION) $(FCSUFFIX) $*.f90

	setfeenv.o : setfeenv.c
		$(RM) $@
		$(CCOMP) -o $@ -c $(CFLAGS) $(OMPCC) $*.c

	.c.o:
		$(RM) $@
		$(CC) -o $@ -c $(CFLAGS) $*.c

	# A little more adventurous.  Allow full opt on 
	# mediation_integrate.o \
	# shift_domain_em.o \
	# solve_em.o  <-- gets a little kick from SOLVE_EM_SPECIAL too, if defined
	# mediation_feedback_domain.o : mediation_feedback_domain.F
	# mediation_force_domain.o : mediation_force_domain.F
	# mediation_interp_domain.o : mediation_interp_domain.F

	# compile these without high optimization to speed compile
	track_driver.o : track_driver.F
	convert_nmm.o : convert_nmm.F
	init_modules_em.o : init_modules_em.F
	input_wrf.o : input_wrf.F
	module_io.o : module_io.F
	module_comm_dm.o : module_comm_dm.F
	module_comm_dm_0.o : module_comm_dm_0.F
	module_comm_dm_1.o : module_comm_dm_1.F
	module_comm_dm_2.o : module_comm_dm_2.F
	module_comm_dm_3.o : module_comm_dm_3.F
	module_comm_nesting_dm.o : module_comm_nesting_dm.F
	module_configure.o : module_configure.F
	module_domain.o : module_domain.F
	module_domain_type.o : module_domain_type.F
	module_alloc_space_0.o : module_alloc_space_0.F
	module_alloc_space_1.o : module_alloc_space_1.F
	module_alloc_space_2.o : module_alloc_space_2.F
	module_alloc_space_3.o : module_alloc_space_3.F
	module_alloc_space_4.o : module_alloc_space_4.F
	module_alloc_space_5.o : module_alloc_space_5.F
	module_alloc_space_6.o : module_alloc_space_6.F
	module_alloc_space_7.o : module_alloc_space_7.F
	module_alloc_space_8.o : module_alloc_space_8.F
	module_alloc_space_9.o : module_alloc_space_9.F
	module_tiles.o : module_tiles.F
	module_initialize.o : module_initialize.F
	module_physics_init.o : module_physics_init.F 
	module_initialize_squall2d_x.o : module_initialize_squall2d_x.F
	module_initialize_squall2d_y.o : module_initialize_squall2d_y.F
	module_initialize_scm_xy.o : module_initialize_scm_xy.F
	module_integrate.o : module_integrate.F
	module_io_mm5.o : module_io_mm5.F
	module_io_wrf.o : module_io_wrf.F
	module_si_io.o : module_si_io.F
	module_wps_io_arw.o : module_wps_io_arw.F
	module_state_description.o : module_state_description.F 
	output_wrf.o : output_wrf.F
	solve_interface.o : solve_interface.F
	start_domain.o : start_domain.F
	wrf_bdyin.o : wrf_bdyin.F
	wrf_bdyout.o : wrf_bdyout.F
	wrf_ext_read_field.o : wrf_ext_read_field.F
	wrf_ext_write_field.o : wrf_ext_write_field.F
	wrf_fddaobs_in.o : wrf_fddaobs_in.F
	wrf_histin.o : wrf_histin.F
	wrf_histout.o : wrf_histout.F
	wrf_inputin.o : wrf_inputin.F
	wrf_inputout.o : wrf_inputout.F
	wrf_restartin.o : wrf_restartin.F
	wrf_restartout.o : wrf_restartout.F
	wrf_tsin.o : wrf_tsin.F
	nl_get_0_routines.o : nl_get_0_routines.F
	nl_get_1_routines.o : nl_get_1_routines.F
	nl_set_0_routines.o : nl_set_0_routines.F
	nl_set_1_routines.o : nl_set_1_routines.F

	track_driver.o \
	convert_nmm.o \
	init_modules_em.o \
	module_initialize.o \
	module_initialize_squall2d_x.o \
	module_initialize_squall2d_y.o \
	module_initialize_scm_xy.o \
	module_integrate.o \
	module_io_mm5.o \
	module_io_wrf.o \
	module_si_io.o \
	module_wps_io_arw.o \
	module_tiles.o \
	output_wrf.o \
	solve_interface.o \
	start_domain.o \
	wrf_fddaobs_in.o \
	wrf_tsin.o :
		$(RM) $@
		$(SED_FTN) $*.F > $*.b 
		$(CPP) -I$(WRF_SRC_ROOT_DIR)/inc $(CPPFLAGS) $(OMPCPP) $*.b  > $*.f90
		$(RM) $*.b
		@ if echo $(ARCHFLAGS) | $(FGREP) 'DVAR4D'; then \
		  echo COMPILING $*.F for 4DVAR ; \
		  $(WRF_SRC_ROOT_DIR)/var/build/da_name_space.pl $*.f90 > $*.f90.tmp ; \
		  mv $*.f90.tmp $*.f90 ; \
		fi
		if $(FGREP) '!$$OMP' $*.f90 ; then \
		  if [ -n "$(OMP)" ] ; then echo COMPILING $*.F WITH OMP ; fi ; \
		  $(FC) -c $(PROMOTION) $(FCNOOPT) $(FCBASEOPTS) $(MODULE_DIRS) $(FCSUFFIX) $(OMP) $*.f90 ; \
		else \
		  if [ -n "$(OMP)" ] ; then echo COMPILING $*.F WITHOUT OMP ; fi ; \
		  $(FC) -c $(PROMOTION) $(FCNOOPT) $(FCBASEOPTS) $(MODULE_DIRS) $(FCSUFFIX) $*.f90 ; \
		fi

	#solve_em.o :
	#	$(RM) $@
	#	$(SED_FTN) $*.F > $*.b 
	#	$(CPP) -I$(WRF_SRC_ROOT_DIR)/inc $(CPPFLAGS) $*.b  > $*.f90
	#	$(RM) $*.b
	#	$(FC) -o $@ -c $(FCFLAGS) $(MODULE_DIRS) $(PROMOTION) $(FCSUFFIX) $(SOLVE_EM_SPECIAL) $(OMP) $*.f90

	module_sf_ruclsm.o : module_sf_ruclsm.F

	module_sf_ruclsm.o :
		$(RM) $@
		$(SED_FTN) $*.F > $*.b 
		$(CPP) -I$(WRF_SRC_ROOT_DIR)/inc $(CPPFLAGS) $(OMPCPP) $*.b  > $*.f90
		$(RM) $*.b
		if $(FGREP) '!$$OMP' $*.f90 ; then \
		  echo COMPILING $*.F WITH OMP ; \
		  if [ -n "$(OMP)" ] ; then echo COMPILING $*.F WITH OMP ; fi ; \
		  $(FC) -c $(PROMOTION) $(FCREDUCEDOPT) $(FCBASEOPTS) $(MODULE_DIRS) $(FCSUFFIX) $(OMP) $*.f90 ; \
		else \
		  if [ -n "$(OMP)" ] ; then echo COMPILING $*.F WITHOUT OMP ; fi ; \
		  $(FC) -c $(PROMOTION) $(FCREDUCEDOPT) $(FCBASEOPTS) $(MODULE_DIRS) $(FCSUFFIX) $*.f90 ; \
		fi

	# compile without OMP
	input_wrf.o \
	module_domain.o \
	module_domain_type.o \
	module_physics_init.o \
	module_io.o \
	wrf_bdyin.o \
	wrf_bdyout.o \
	wrf_ext_read_field.o \
	wrf_ext_write_field.o \
	wrf_histin.o \
	wrf_histout.o \
	wrf_inputin.o \
	wrf_inputout.o \
	wrf_restartin.o \
	wrf_restartout.o \
	module_state_description.o \
	module_alloc_space.o \
	module_alloc_space_0.o \
	module_alloc_space_1.o \
	module_alloc_space_2.o \
	module_alloc_space_3.o \
	module_alloc_space_4.o \
	module_alloc_space_5.o \
	module_alloc_space_6.o \
	module_alloc_space_7.o \
	module_alloc_space_8.o \
	module_alloc_space_9.o \
	module_comm_dm.o \
	module_comm_dm_0.o \
	module_comm_dm_1.o \
		module_comm_dm_2.o \
		module_comm_dm_3.o \
	module_comm_nesting_dm.o \
	module_configure.o :
			$(RM) $@
			$(CPP) -I$(WRF_SRC_ROOT_DIR)/inc $(CPPFLAGS) $(OMPCPP) $*.F  > $*.bb
		$(SED_FTN) $*.bb | $(CPP) $(TRADFLAG) > $*.f90
		@ if echo $(ARCHFLAGS) | $(FGREP) 'DVAR4D'; then \
		  echo COMPILING $*.F for 4DVAR ; \
		  $(WRF_SRC_ROOT_DIR)/var/build/da_name_space.pl $*.f90 > $*.f90.tmp ; \
		  mv $*.f90.tmp $*.f90 ; \
		fi
		$(RM) $*.b $*.bb
		$(FC) -c $(PROMOTION) $(FCSUFFIX) $(FCNOOPT) $(FCBASEOPTS) $(MODULE_DIRS) $*.f90
	```
Alternatively, the `configure.wrf` can also be generated by setting the below modules and environments, and executing `% ./configure` and choosing the appropriate architecture option.

After loading the modules for the appropriate toolchain, supporting netcdf, hdf5, pnetcdf softwares, and setting the netcdf environments, compile the WRF software:

	```
	% export NETCDF=/opt/cray/pe/netcdf/default/CRAYCLANG/14.0
	% ./compile em_real
	```
	

<! ## Troubleshooting

 Include known problems and workarounds here, if applicable !>

